<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[NetEase Java Curriculum]]></title>
      <url>http://chrisp7.github.io/2017/02/22/netease-java-curriculum/</url>
      <content type="html"><![CDATA[<h1 id="Java-web"><a href="#Java-web" class="headerlink" title="Java web"></a>Java web</h1><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><ul>
<li>本身tomcat也是java写的，需要java虚拟机，所以tomcat在启动时可以加一些java的参数</li>
<li>通过环境变量JAVA_OPTS可以给加一些启动参数</li>
</ul>
<h3 id="Tomcat组成与架构"><a href="#Tomcat组成与架构" class="headerlink" title="Tomcat组成与架构"></a>Tomcat组成与架构</h3><ul>
<li>最重要的就是conf下的server.xml文件<ul>
<li>server 根节点<ul>
<li>service 可以有多个service<ul>
<li>connector 用来接受用户请求的，看过就知道他配置了哪个端口处理哪个协议</li>
<li>engine 对于一个service只能有一个，他用来处理connector接收到的一些请求的，包括我们平时写的一些代码都是由engine来执行<ul>
<li>host 在engine里可以有多个host，表示虚拟主机，一般一个ip加一个端口组成一个对。然后我们在请求里加上不同的host头来决定具体路由到哪个host来处理。<ul>
<li>context 一个context就是一个web应用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>一个service就是一个容器（container）</li>
<li>tomcat中实现容器（container）的组件是catalina，最终我们的代码都是由catalina里面的代码来执行的</li>
<li>具体到每个参数<ul>
<li>connector <ul>
<li>有个address参数，他指明了这个容器将要监听到IP地址。因为一个服务器将会有多个IP地址，如果不进行配置，他默认将对所有的IP地址进行监听，而这处于安全方面的考量是不被允许的</li>
<li>protocol 指名用什么协议，一般开发不会更改，到后面性能调优的时候会有涉及</li>
<li>acceptCount 这个参数是用来指明当所有线程都用来处理请求，你的等待队列的长度。有点像理发师那个程序里buffer的长度。</li>
<li>maxConnections 最大连接数。需要注意的是他是和你能生成的最大线程数相关的。当你把他的值设为-1的时候表示不限制最大连接数。当然，你虽然设置了-1，但是最大连接数还是要受其他资源的限制。也就是说还是会有最大连接数的</li>
</ul>
</li>
</ul>
</li>
<li>线程池 传统的请求响应方式是你来一个请求，我创建一个线程，建立一个连接，处理这个请求。等请求结束就回收这次的资源。但是这将遇到一个问题就是非常地耗时，因为每次都建立和销毁都是要时间的。所以机智的人类想出来一个方法就是我先提前创建一些线程放在线程池，然后有请求来就响应，响应结束后并不销毁。这就好像医院里面的挂号服务，不管你有没有病人来，挂号窗口都是有服务人员的。<ul>
<li>他的配置项是<executor></executor></li>
<li>最小空闲线程数（minSpareThreads） 用来设置线程池最小的线程数。这就好比医院要求的挂号服务在一般情况下最少要有多少个窗口有人值班。</li>
<li>最大线程数 （maxThreads） 用来表示这个线程池能接受的最大线程数。同样类比到挂号服务，就是最多能有多少窗口同时开启工作。之后来的人就得等待。</li>
<li>这两个参数可以直接配置在connector里面，也可以单独的配在Executor里面，然后在connector里面指定依赖关系。</li>
<li>这两个参数构成了另一个概念，弹性线程池。当多于minSpareThreads规定的请求数的时候就会创建其他线程到线程池处理请求，直到创建到最大值。当只有少数请求时，就只开minSpareThreads规定的线程数在线程池。</li>
</ul>
</li>
<li>日志<ul>
<li>日志分类<ul>
<li>系统运行日志 记录tomcat运行状态，结果等。会捕获一些异常</li>
<li>访问日志 记录所有的请求</li>
<li>应用日志 用户自己写的</li>
</ul>
</li>
<li>配置访问日志 也是在server.xml里面配置<ul>
<li>在标签Valve里面配置</li>
<li>prefix 指定了你日志命名的开头</li>
<li>suffix 指定日志命名的结尾</li>
<li>pattern 指名日志里面每一条记录所记录的东西<ul>
<li>请求方法是%m ，客户端IP是 %a ，请求时间是 %t ，请求方法是%r ，状态码是%s ，客户端代理是%{User-agent}i<br>*fileDateFormat 他常常搭配另一个参数rotatable，当rotatable为true时，fileDateFormat指定了日志以怎样的格式切割。（日志文件切割的意义在于使日志文件不至于过大，这样不至于你检索和查看都会很慢。）如：fileDateFormat: yyyy-MM-dd.时，日志就会每天滚动一次，如果设置成yyyy-MM-dd.HH.那么他每小时就会滚动一次。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><ul>
<li>groupId 组织名 一般就是用你项目包的前缀命名，如：com.chrisp7</li>
<li>artifactId 项目标识符，一般就是写项目名字。不要加点。</li>
<li>version 版本 一般都是x.y.z这样的格式。如果你是在开发过程中，那么可以在后面加上一个SNAPSHOT，这样maven会根据这个判断出他是一个在开发的版本。这样maven在你不改版本号的情况下也能判断出哪个新哪个旧。因为她会根据SNAPSHOT自动的打上时间戳。<blockquote>
<p>groupId artifactId version 是maven中一个项目的坐标，通过这个三个值可以唯一的定位一个项目。这三个的值不能重复。</p>
</blockquote>
</li>
<li>package 类型，如：war<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3></li>
<li>mvn archetype:generate 根据模板生成项目</li>
<li>mvn compile 编译源代码</li>
<li>mvn test 跑测试</li>
<li>mvn package 打包</li>
<li>mvn 生成项目相关的站点，在线文档</li>
<li>mvn install 将包安装到本地仓库，让其他项目进行依赖<h3 id="使用maven"><a href="#使用maven" class="headerlink" title="使用maven"></a>使用maven</h3></li>
<li>使用maven:generate后maven会自动为你生成一些目录，而你的Java文件必须写在src下的java文件中，就像这样<img src="/2017/02/22/netease-java-curriculum/maven_directory.png" alt="maven_directory.png" title=""></li>
<li><h2 id="实践中的一些心得"><a href="#实践中的一些心得" class="headerlink" title="实践中的一些心得"></a>实践中的一些心得</h2></li>
</ul>
<ol>
<li>当你在做服务端开发，需要修改一些配置文件的时候一定要记得备份。可以直接使用如：cp server.xml server.xml.bak命令</li>
<li>访问网址不一定要用chrome，在终端就可以用curl命令。如：curl <a href="http://baidu.com" target="_blank" rel="external">http://baidu.com</a></li>
<li>telnet可以实现发请求发一半，实现占着一个线程的效果</li>
<li>在linux系统中终端里想看文本内容，可以用cat命令</li>
<li>解压tar.gz文件使用命令 tar xvzf xxx.tar.gz</li>
<li>希望在终端打包成一个war包。可以使用命令：jar cvf xxx.war . （别忘了后面有个点，代表当前路径）</li>
<li>如果希望使用剪切的效果。那就使用mv命令啊，别用cp命令</li>
<li>可以使用javac -cp apache-tomcat/lib/servlet-api.jar WEB-INF/xxx.java 的方式指定用某个api编译某个Java文件，将其编译为class文件</li>
<li>add external jar jar包没有拷贝进项目 add jar jar包拷贝进了项目</li>
<li></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Technology </category>
            
        </categories>
        
        
        <tags>
            
            <tag> work_orientated </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[个人markdown常用语法]]></title>
      <url>http://chrisp7.github.io/2017/02/16/%E4%B8%AA%E4%BA%BAmarkdwon%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="Markdown常用语法"><a href="#Markdown常用语法" class="headerlink" title="Markdown常用语法"></a>Markdown常用语法</h1><h2 id="1、-用-区分标题级别"><a href="#1、-用-区分标题级别" class="headerlink" title="1、 用#区分标题级别"></a>1、 用<code>#</code>区分标题级别</h2><p>markdown支持6级标题，一级标题是一个<code>#</code>，以此类推，六级标题就是六个<code>#</code></p>
<h2 id="2、强调"><a href="#2、强调" class="headerlink" title="2、强调"></a>2、强调</h2><p>两个 <code>*</code> 或者 <code>-</code> 代表加粗，一个 <code>*</code> 或 <code>-</code> 表示斜体</p>
<p>效果：<strong>加粗文本</strong>，<em>斜体文本</em></p>
<h2 id="3、无序-amp-有序列表"><a href="#3、无序-amp-有序列表" class="headerlink" title="3、无序&amp;有序列表"></a>3、无序&amp;有序列表</h2><p>无序列表使用-、+、*<br>有序列表使用数字加英文句点 </p>
<p>效果：</p>
<ul>
<li>A</li>
<li>B</li>
<li>C</li>
</ul>
<ol>
<li>A</li>
<li>B</li>
<li>C</li>
</ol>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>使用引用时用 &gt; </p>
<p>效果：</p>
<blockquote>
<p>这是一段引用</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Technology </category>
            
        </categories>
        
        
        <tags>
            
            <tag> self_learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[problem using hexo]]></title>
      <url>http://chrisp7.github.io/2017/02/15/problem-using-hexo/</url>
      <content type="html"><![CDATA[<h1 id="安装hexo所遇问题"><a href="#安装hexo所遇问题" class="headerlink" title="安装hexo所遇问题"></a>安装hexo所遇问题</h1><h2 id="使用脚本-amp-amp-修改权限"><a href="#使用脚本-amp-amp-修改权限" class="headerlink" title="使用脚本&amp;&amp;修改权限"></a>使用脚本&amp;&amp;修改权限</h2><p>对于每一次的部署我们知道都是同样的三个命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$hexo</span> clean</div><div class="line"><span class="variable">$hexo</span> generate</div><div class="line"><span class="variable">$hexo</span> deploy</div></pre></td></tr></table></figure></p>
<p>于是可以选择用脚本执行。在我将其写进脚本后发现并不能执行。用l命令查看后只有可读可写权限，光头告诉我要修改权限，让他可执行。很久没用chmod命令，这次光头一提醒发现他的参数确实很容易记，就是(u/g/o)+(r/w/x) 然后跟文件名即可。如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod u+x filename</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="command-not-found-hexo"><a href="#command-not-found-hexo" class="headerlink" title="command not found : hexo"></a>command not found : hexo</h2><p>当我第二天准备重新使用前一天写的脚本来自动化的部署一次我的md文件时，却报出来<code>command not found : hexo</code> 我的第一反应是难道昨天用npm装了那么多次的hexo又没了？于是当我尝试用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo</div></pre></td></tr></table></figure></p>
<p>他又报错 <code>command not found : npm</code> 此时我已不只是怀疑hexo出了问题。显然npm是和node一起装的，我又用同样的方式检查了一遍node。果然又出现<code>command not found : node</code><br>这才明白是从node这儿出了问题。<br>google之后，发现正常的安装node后他会出现在/usr/local/bin中，然而当我去检查时却发现并没有node。我想起之前是用nvm安装的node，并且之前我有记录hexo的路径，打开hexo所在文件夹果然node就在里面。于是我将node所在目录写进了.bash_profile.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> <span class="string">'export PATH=$PATH:$HOME/.nvm/versions/node/v6.9.4/bin'</span> &gt;&gt; <span class="variable">$HOME</span>/.bash_profile</div></pre></td></tr></table></figure></p>
<p>生效过后，发现node可以用了。npm 和 hexo 的问题也都解决了。</p>
<p>由此问题以后看到<code>command not found : xxx</code>便可知道一定是你的PATH里没有放你要用的命令的路径，并且这儿命令如果是后来装的，那么他大多会出现在/usr/local/bin下 因为mac下这个目录就是用来保存你后期用brew或者其他方式下载的可执行命令。</p>
<hr>
<h2 id="hexo-目录"><a href="#hexo-目录" class="headerlink" title="hexo 目录"></a>hexo 目录</h2><p><strong>/Users/CP/.nvm/versions/node/v6.9.4/lib/node_modules/hexo-cli/bin/hexo</strong></p>
<hr>
<h2 id="点击顶部菜单栏时显示404"><a href="#点击顶部菜单栏时显示404" class="headerlink" title="点击顶部菜单栏时显示404"></a>点击顶部菜单栏时显示404</h2><p>当我点击除了home以外的菜单栏按钮时，都出现了404 not found 的问题，页面不存在。经过网上查阅资料，发现是没有新建页面。于是我使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo new page xxx</div></pre></td></tr></table></figure></p>
<p>依次新建了tags、categories页面。这样就可以访问了。</p>
<blockquote>
<p><strong><code>注意</code></strong><br>这里在新建了页面后，hexo会在对应的目录下新建一个index.md的文件，你需要在front-matter里面加上一行type属性，以指名他对应的menu</p>
</blockquote>
<hr>
<h2 id="引用图片"><a href="#引用图片" class="headerlink" title="引用图片"></a>引用图片</h2><p>对于文章中只有少量图片的情况，只需将图片放在source/images文件夹即可。然后使用 <code>![] (/images/image.jpg)</code> 引用图片即可<br>对于有多张图片的情况，建议集中管理。首先先到_config.yml 设置</p>
<blockquote>
<p>_config.yml<br>post_asset_folder: true</p>
</blockquote>
<p>此时资源文件管理功能打开，以后每次用hexo new [layout] “xxx” 新建文章时，都会在你新建的markdown文件同一个文件夹下新建一个和你命名的markdown文件同名的资源文件夹，然后与这篇文章所有相关的资源文件都可以放在这里，然后用标签插件进行引用。如：</p>
<blockquote>

</blockquote>
<hr>
<h2 id="结束引用"><a href="#结束引用" class="headerlink" title="结束引用"></a>结束引用</h2><p>如果想结束引用，只要连按两下回车就行。</p>
]]></content>
      
        <categories>
            
            <category> Technology </category>
            
        </categories>
        
        
        <tags>
            
            <tag> self_learning </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
